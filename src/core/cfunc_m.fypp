! Module  : cfunc_m
! Purpose : callable function objects & solvers
 
#:include 'core.inc'

module cfunc_m

  ! Uses

  use kinds_m

  use ISO_FORTRAN_ENV

  ! No implicit typing

  implicit none

  ! Derived-type definitions

  type, abstract :: cfunc_t
   contains
     private
     procedure                    :: eval_r_
     procedure(eval_c_), deferred :: eval_c_
     generic, public              :: eval => eval_r_, eval_c_
     procedure, public            :: expand_bracket => expand_bracket_
     procedure, public            :: narrow_bracket => narrow_bracket_
     procedure                    :: root_r_
     procedure                    :: root_c_
     generic, public              :: root => root_r_, root_c_
     procedure, public            :: minimum => minimum_r_
     procedure, public            :: maximum => maximum_r_
  end type cfunc_t

  ! Interfaces

  abstract interface
    function eval_c_(this, z) result(f_z)
      use kinds_m
      import cfunc_t
      class(cfunc_t), intent(inout) :: this
      complex(RD), intent(in)       :: z
      complex(RD)                   :: f_z
    end function eval_c_
  end interface

  ! Access specifiers

  private

  public :: cfunc_t

  ! Procedures

contains

    function eval_r_(this, x) result(f_x)

    class(cfunc_t), intent(inout) :: this
    real(RD), intent(in)          :: x
    real(RD)                      :: f_x

    ! Evaluate the real function based on the complex function
    ! this%eval(z)

    f_x = REAL(this%eval(CMPLX(x, KIND=RD)), RD)

    ! Finish

    return

  end function eval_r_

!****

  subroutine expand_bracket_(this, x_a, x_b, f_x_a, f_x_b, clamp_a, clamp_b)

    class(cfunc_t), intent(inout)   :: this
    real(RD), intent(inout)         :: x_a
    real(RD), intent(inout)         :: x_b
    real(RD), intent(out), optional :: f_x_a
    real(RD), intent(out), optional :: f_x_b
    logical, intent(in), optional   :: clamp_a
    logical, intent(in), optional   :: clamp_b

    real(RD), parameter :: EXPAND_FACTOR = 1.6_RD

    logical  :: clamp_a_
    logical  :: clamp_b_
    real(RD) :: f_a
    real(RD) :: f_b
    logical  :: move_a

    if(PRESENT(clamp_a)) then
       clamp_a_ = clamp_a
    else
       clamp_a_ = .FALSE.
    endif

    if(PRESENT(clamp_b)) then
       clamp_b_ = clamp_b
    else
       clamp_b_ = .FALSE.
    endif

    @:ASSERT(.NOT. (clamp_a_ .AND. clamp_b_), 'Cannot clamp both points')

    @:ASSERT(x_a /= x_b, 'Invalid initial bracket')

    ! Expand the bracket [x_a,x_b] until it contains a root of the real function this%eval(x)

    f_a = this%eval(x_a)
    f_b = this%eval(x_b)

    expand_loop : do

       if((f_a > 0._RD .AND. f_b < 0._RD) .OR. &
          (f_a < 0._RD .AND. f_b > 0._RD)) exit expand_loop

       if(clamp_a_) then
          move_a = .FALSE.
       elseif(clamp_b_) then
          move_a = .TRUE.
       else
          move_a = ABS(f_b) > ABS(f_a)
       endif

       if(move_a) then
          x_a = x_a + EXPAND_FACTOR*(x_a - x_b)
          f_a = this%eval(x_a)
       else
          x_b = x_b + EXPAND_FACTOR*(x_b - x_a)
          f_b = this%eval(x_b)
       endif

    end do expand_loop

    ! Store f_a and f_b

    if(PRESENT(f_x_a)) f_x_a = f_a
    if(PRESENT(f_x_b)) f_x_b = f_b

    ! Finish

    return

  end subroutine expand_bracket_

!****

  subroutine narrow_bracket_(this, x_a, x_b, x_tol, f_x_a, f_x_b, n_iter, relative_tol)

    class(cfunc_t), intent(inout)     :: this
    real(RD), intent(inout)           :: x_a
    real(RD), intent(inout)           :: x_b
    real(RD), intent(in)              :: x_tol
    real(RD), optional, intent(inout) :: f_x_a
    real(RD), optional, intent(inout) :: f_x_b
    integer, optional, intent(inout)  :: n_iter
    logical, optional, intent(in)     :: relative_tol

    real(RD), parameter :: EPS = EPSILON(0._RD)

    integer  :: n_iter_
    logical  :: relative_tol_
    real(RD) :: a
    real(RD) :: b
    real(RD) :: c
    real(RD) :: d
    real(RD) :: e
    real(RD) :: f_a
    real(RD) :: f_b
    real(RD) :: f_c
    real(RD) :: tol
    real(RD) :: m
    real(RD) :: p
    real(RD) :: q
    real(RD) :: r
    real(RD) :: s
    integer  :: i

    if(PRESENT(n_iter)) then
       n_iter_ = n_iter
    else
       n_iter_ = 75
    end if

    if(PRESENT(relative_tol)) then
       relative_tol_ = relative_tol
    else
       relative_tol_ = .FALSE.
    endif

    ! Use Brent's method [based on the ALGOL 60 routine 'zero'
    ! published in Brent (1973, "Algorithms for Minimization without
    ! Derivatives", Prentice Hall, Englewood Cliffs] to narrow the
    ! bracket [x_a,x_b] bracket on the real function this%eval(x)

    ! Set up the initial state

    a = x_a
    b = x_b

    if(PRESENT(f_x_a)) then
       f_a = f_x_a
    else
       f_a = this%eval(a)
    endif

    if(PRESENT(f_x_b)) then
       f_b = f_x_b
    else
       f_b = this%eval(b)
    endif

    c = b
    f_c = f_b

    ! Check that a root does indeed lie within the bracket

    @:ASSERT((f_a >= 0._RD .AND. f_b <= 0._RD) .OR. (f_a <= 0._RD .AND. f_b >= 0._RD), 'Root is not bracketed')

    ! Iterate until the correction drops below the threshold, or the
    ! maximum number of iterations is exceeded

    iterate_loop : do i = 1,n_iter_

       ! Reorder c so that it has the opposite sign to b

       if(f_b > 0. .EQV. f_c > 0.) then
          c = a
          f_c = f_a
          d = b - a
          e = d
       endif

       ! Make sure that the function is smallest in magnitude
       ! at b
          
       if(ABS(f_c) < ABS(f_b)) then
          a = b
          b = c
          c = a
          f_a = f_b
          f_b = f_c
          f_c = f_a
       endif

       if(relative_tol_) then
          tol = (2.*EPS + x_tol)*ABS(b)
       else
          tol = 2.*EPS*ABS(b) + x_tol
       endif

       m = 0.5*(c - b)

       ! Check for convergence

       if(ABS(m) <= tol .OR. f_b == 0.) exit iterate_loop

       ! See if bisection is forced

       if(ABS(e) <  tol .OR. ABS(f_a) < ABS(f_b)) then

          d = m
          e = d

       else

          s = f_b/f_a

          if(a == c) then

             ! Linear interpolation

             p = 2.*m*s
             q = 1. - s

          else

             ! Inverse quadratic interpolation

             q = f_a/f_c
             r = f_b/f_c

             p = s*(2.*m*q*(q - r) - (b - a)*(r - 1.))
             q = (q - 1.)*(r - 1.)*(s - 1.)

          endif

          if(p > 0.) then
             q = -q
          else
             p = -p
          endif

          s = e
          e = d

          if(2.*p < 3.*m*q - ABS(tol*q) .AND. p < ABS(0.5*s*q)) then
             d = p/q
          else
             d = m
             e = d
          endif

       endif

       ! Store the old value of b in a

       a = b
       f_a = f_b

       ! Update b

       b = b + MERGE(d, MERGE(tol, -tol, m > 0), ABS(d) > tol)

       f_b = this%eval(b)

    end do iterate_loop

    if(PRESENT(n_iter)) then
       n_iter = i
    else
       @:ASSERT(i <= n_iter_, 'Too many iterations')
    endif

    ! Store the results

    x_a = a
    x_b = b

    if(PRESENT(f_x_a)) f_x_a = f_a
    if(PRESENT(f_x_b)) f_x_b = f_b

    ! Finish

    return

  end subroutine narrow_bracket_

!****

  function root_r_(this, x_a, x_b, x_tol, f_x_a, f_x_b, n_iter, relative_tol) result(x)

    class(cfunc_t), intent(inout)    :: this
    real(RD), intent(in)             :: x_a
    real(RD), intent(in)             :: x_b
    real(RD), intent(in)             :: x_tol
    real(RD), optional, intent(in)   :: f_x_a
    real(RD), optional, intent(in)   :: f_x_b
    integer, optional, intent(inout) :: n_iter
    logical, optional, intent(in)    :: relative_tol
    real(RD)                         :: x

    real(RD) :: a
    real(RD) :: b
    real(RD) :: f_a
    real(RD) :: f_b

    ! Find a root of the real function this%eval(x)

    a = x_a
    b = x_b

    if(PRESENT(f_x_a)) then
       f_a = f_x_a
    else
       f_a = this%eval(a)
    endif

    if(PRESENT(f_x_b)) then
       f_b = f_x_b
    else
       f_b = this%eval(b)
    endif

    call this%narrow_bracket(a, b, x_tol, f_a, f_b, n_iter, relative_tol)

    x = b

    ! Finish

    return

  end function root_r_

!****

  function root_c_(this, z_a, z_b, z_tol, f_z_a, f_z_b, n_iter, relative_tol) result(z)

    class(cfunc_t), intent(inout)     :: this
    complex(RD), intent(in)           :: z_a
    complex(RD), intent(in)           :: z_b
    real(RD), intent(in)              :: z_tol
    complex(RD), optional, intent(in) :: f_z_a
    complex(RD), optional, intent(in) :: f_z_b
    integer, optional, intent(inout)  :: n_iter
    logical, optional, intent(in)     :: relative_tol
    complex(RD)                       :: z

    real(RD), parameter :: EPS = EPSILON(0._RD)

    integer     :: n_iter_
    logical     :: relative_tol_
    complex(RD) :: a
    complex(RD) :: b
    complex(RD) :: c
    complex(RD) :: f_a
    complex(RD) :: f_b
    complex(RD) :: f_c
    integer     :: i
    complex(RD) :: f_dz
    complex(RD) :: rho
    real(RD)    :: tol

    if(PRESENT(n_iter)) then
       n_iter_ = n_iter
    else
       n_iter_ = 50
    end if

    if(PRESENT(relative_tol)) then
       relative_tol_ = relative_tol
    else
       relative_tol_ = .FALSE.
    endif

    ! Use the secant method to find a complex root of the function
    ! this%eval(z)

    ! Set up the initial state

    a = z_a
    b = z_b

    if(PRESENT(f_z_a)) then
       f_a = f_z_a
    else
       f_a = this%eval(a)
    endif

    if(PRESENT(f_z_b)) then
       f_b = f_z_b
    else
       f_b = this%eval(b)
    endif

    if(ABS(f_a) < ABS(f_b)) then

       c = a
       a = b
       b = c

       f_c = f_a
       f_a = f_b
       f_b = f_c

    endif

    ! Iterate until the correction drops below the threshold, or the
    ! maximum number of iterations is exceeded

    iterate_loop : do i = 1,n_iter_

       ! Calculate the correction

       f_dz = f_b*(b - a)

       rho = f_b - f_a

       ! Check for a singular correction

       if(ABS(b*rho) < 8._RD*EPS*ABS(f_dz)) then
          @:ABORT('Singular correction in secant')
       endif

       ! Update the root

       a = b
       f_a = f_b

       b = b - f_dz/rho
       f_b = this%eval(b)

       ! Check for convergence

       if(relative_tol_) then
          tol = (4._RD*EPS + z_tol)*ABS(b)
       else
          tol = 4._RD*EPS*ABS(b) + z_tol
       endif

       if((ABS(b - a) <= tol .OR. f_b == 0._RD)) exit iterate_loop

    end do iterate_loop

    if(PRESENT(n_iter)) then
       n_iter = i
    else
       @:ASSERT(i <= n_iter_, 'Too many iterations')
    endif

    ! Store the result

    z = b

    ! Finish

  end function root_c_

!****

  function minimum_r_(this, x_a, x_b, x_c, x_tol, relative_tol) result(x)

    class(cfunc_t), intent(inout) :: this
    real(RD), intent(in)          :: x_a
    real(RD), intent(in)          :: x_b
    real(RD), intent(in)          :: x_c
    real(RD), intent(in)          :: x_tol
    logical, intent(in), optional :: relative_tol
    real(RD)                      :: x

    ! Find a local minimum of the real function this%eval(x)
    
    x = extremum_(this, x_a, x_b, x_c, x_tol, .TRUE., relative_tol)

    ! Finish

    return

  end function minimum_r_

!****

  function maximum_r_(this, x_a, x_b, x_c, x_tol, relative_tol) result(x)

    class(cfunc_t), intent(inout) :: this
    real(RD), intent(in)          :: x_a
    real(RD), intent(in)          :: x_b
    real(RD), intent(in)          :: x_c
    real(RD), intent(in)          :: x_tol
    logical, intent(in), optional :: relative_tol
    real(RD)                      :: x

    ! Find a local maximum of the real function this%eval(x)
    
    x = extremum_(this, x_a, x_b, x_c, x_tol, .FALSE., relative_tol)

    ! Finish

    return

  end function maximum_r_

!****

  function extremum_(rf, x_a, x_b, x_c, x_tol, minimum, relative_tol) result(x)

    class(cfunc_t), intent(inout) :: rf
    real(RD), intent(in)          :: x_a
    real(RD), intent(in)          :: x_b
    real(RD), intent(in)          :: x_c
    real(RD), intent(in)          :: x_tol
    logical, intent(in)           :: minimum
    logical, intent(in), optional :: relative_tol
    real(RD)                      :: x

    real(RD), parameter :: EPS = EPSILON(0._RD)
    real(RD), parameter :: R = 0.61803399_RD
    real(RD), parameter :: C = 1._RD - R

    logical  :: relative_tol_
    real(RD) :: x_0
    real(RD) :: x_1
    real(RD) :: x_2
    real(RD) :: x_3
    real(RD) :: f_1
    real(RD) :: f_2
    real(RD) :: tol

    if(PRESENT(relative_tol)) then
       relative_tol_ = relative_tol
    else
       relative_tol_ = .FALSE.
    endif

    ! Use a golden section search to find a local extremum of the real
    ! function this%eval(x)

    ! Set up the starting locations

    x_0 = x_a
    x_3 = x_c

    if(ABS(x_c-x_b) > ABS(x_b-x_a)) then
       x_1 = x_b
       x_2 = x_b + C*(x_c-x_b)
    else
       x_2 = x_b
       x_1 = x_b - C*(x_b-x_a)
    end if

    ! Iterate until convergence

    f_1 = rf%eval(x_1)*MERGE(1._RD, -1._RD, minimum)
    f_2 = rf%eval(x_2)*MERGE(1._RD, -1._RD, minimum)

    iterate_loop : do

       ! Check for a converged bracket

       if(relative_tol_) then
          tol = (SQRT(EPS) + 0.5_RD*x_tol)*(ABS(x_1) + ABS(x_2))
       else
          tol = SQRT(EPS)*(ABS(x_1) + ABS(x_2)) + x_tol
       endif

       if (ABS(x_3-x_0) <= tol) exit iterate_loop

       ! Update the bracket

       if (f_2 < f_1) then
          call shft3_(x_0, x_1, x_2, R*x_2+C*x_3)
          call shft2_(f_1, f_2, rf%eval(x_2)*MERGE(1._RD, -1._RD, minimum))
       else
          call shft3_(x_3, x_2, x_1, R*x_1+C*x_0)
          call shft2_(f_2, f_1, rf%eval(x_1)*MERGE(1._RD, -1._RD, minimum))
       end if

    end do iterate_loop

    ! Select the lower point

    if (f_1 < f_2) then
       x = x_1
    else
       x = x_2
    endif

    ! Finish

    return

  contains

    subroutine shft2_(a, b, c)

      real(RD), intent(out)   :: a
      real(RD), intent(inout) :: b
      real(RD), intent(in)    :: c

      ! Shift b to a and c to b

      a=b
      b=c

      ! Finish

      return

    end subroutine shft2_

    subroutine shft3_(a, b, c, d)

      real(RD), intent(out)   :: a 
      real(RD), intent(inout) :: b 
      real(RD), intent(inout) :: c
      real(RD), intent(in)    :: d

      ! Shift b to a, c to b and d to c

      a=b
      b=c
      c=d

    end subroutine shft3_

  end function extremum_

end module cfunc_m
