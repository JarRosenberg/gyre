! Module   : core_hgroup
! Purpose  : HDF5 input/output

#:include 'core.inc'

#!!
#! Standard macro to call HDF5
#!!

#:def HDF5_CALL(proc, *vars_pos, **vars_kw)
   #:set vars = vars_pos + ['hdf_err'] + ['{:s}={:s}'.format(key, value) for key, value in vars_kw.items()]
   #:set arg_list = '(' + ','.join(vars) + ')'
   call ${proc}$${arg_list}$
   if (hdf_err == -1) then
      #:if DEBUG
         call h5eprint_f(hdf_err)
      #:endif
      @:ABORT('error in call to ${proc}$')
   endif
#:enddef

module hgroup_m

   ! Uses
   
   use kinds_m

   use hdf5

   use ISO_FORTRAN_ENV
   use ISO_C_BINDING

   ! No implicit typing

   implicit none

   ! Parameters

   integer, parameter :: CREATE_FILE = 1
   integer, parameter :: OPEN_FILE_RO = 2
   integer, parameter :: OPEN_FILE_RW = 3

   ! Derived-type definitions

   type hgroup_t
      private
      integer(HID_T)   :: file_id = 0
      integer(HID_T)   :: group_id = 0
      integer, pointer :: ref_count => null()
   contains
      private
      procedure, public :: final => final_
      procedure, public :: exists => exists_
   end type hgroup_t

   ! Module variables

   integer, save        :: ref_count = 0
   integer(HID_T), save :: c_dp_mem_type_id
   integer(HID_T), save :: c_dp_file_type_id

   ! Interfaces

   interface hgroup_t
      module procedure init_file_
      module procedure init_group_
   end interface hgroup_t

   #:for S in MATH_SUFFIXES+CHAR_SUFFIXES
      #:for R in range(0, 5)
      
         interface read_attr
            module procedure read_attr_${S}$_${R}$_
         end interface read_attr

         interface read_dset
            module procedure read_dset_${S}$_${R}$_
         end interface read_dset

         interface read_attr_alloc
            module procedure read_attr_alloc_${S}$_${R}$_
         end interface read_attr_alloc

         interface read_dset_alloc
            module procedure read_dset_alloc_${S}$_${R}$_
         end interface read_dset_alloc

         interface write_attr
            module procedure write_attr_${S}$_${R}$_
         end interface write_attr

         interface write_dset
            module procedure write_dset_${S}$_${R}$_
         end interface write_dset

      #:endfor
   #:endfor
         
   interface attr_exists
      module procedure attr_exists_
   end interface attr_exists
   
   interface dset_exists
      module procedure dset_exists_
   end interface dset_exists

   ! Access specifiers

   public :: CREATE_FILE
   public :: OPEN_FILE_RO
   public :: OPEN_FILE_RW
   public :: hgroup_t
   public :: read_attr
   public :: read_dset
   public :: read_attr_alloc
   public :: read_dset_alloc
   public :: write_attr
   public :: write_dset
   public :: get_attr_shape
   public :: get_dset_shape
   public :: elem_group_name
   public :: attr_exists
   public :: dset_exists

   ! Default access

   private

contains

   function init_file_(file_name, access_type) result(hg)

      character(*), intent(in) :: file_name
      integer, intent(in)      :: access_type
      type(hgroup_t)           :: hg

      integer        :: hdf_err
      integer(HID_T) :: file_id
      integer(HID_T) :: group_id

      ! If necessary, open the HDF5 library

      if(ref_count == 0) then
         call open_library_()
      endif

      ref_count = ref_count + 1

      ! Depending on the access_type, open or create the file

      select case(access_type)
      case(CREATE_FILE)
         @:HDF5_CALL(h5fcreate_f, file_name, H5F_ACC_TRUNC_F, file_id)
      case(OPEN_FILE_RO)
         @:HDF5_CALL(h5fopen_f, file_name, H5F_ACC_RDONLY_F, file_id)
      case(OPEN_FILE_RW)
         @:HDF5_CALL(h5fopen_f, file_name, H5F_ACC_RDWR_F, file_id)
      case default
         @:ABORT('invalid access_type')
      end select

      ! Open the root group

      @:HDF5_CALL(h5gopen_f, file_id, '/', group_id)

      ! Construct the hgroup_t

      hg%file_id = file_id
      hg%group_id = group_id

      allocate(hg%ref_count)
      hg%ref_count = 1

      ! Finish

      return

   end function init_file_

   !****

   function init_group_(hg_parent, group_name) result(hg)

      type(hgroup_t), intent(inout) :: hg_parent
      character(*), intent(in)      :: group_name
      type(hgroup_t)                :: hg

      integer        :: hdf_err
      integer(HID_T) :: group_id

      ! Depending on whether the group already exists, open or create it

      if(hg_parent%exists(group_name)) then
         @:HDF5_CALL(h5gopen_f, hg_parent%group_id, group_name, group_id)
      else
         @:HDF5_CALL(h5gcreate_f, hg_parent%group_id, group_name, group_id)
      endif

      ! Construct the hgroup_t

      hg%file_id = hg_parent%file_id
      hg%group_id = group_id

      hg%ref_count => hg_parent%ref_count
      hg%ref_count = hg%ref_count + 1

      ! Finish

      return

   end function init_group_

   !****

   subroutine open_library_()

      integer :: hdf_err

      ! Open the HDF5 library

      @:HDF5_CALL(h5open_f)

      ! Create complex data types

      call create_complex_type_(mem_type_r_(), c_dp_mem_type_id)

      call create_complex_type_(mem_type_r_(), c_dp_file_type_id)

      ! Finish

      return

   contains

      subroutine create_complex_type_(comp_type_id, type_id)

         integer(HID_T), intent(in)  :: comp_type_id
         integer(HID_T), intent(out) :: type_id

         integer         :: hdf_err
         integer(SIZE_T) :: comp_size

         ! Create a complex data type

         @:HDF5_CALL(h5tget_size_f, comp_type_id, comp_size)

         @:HDF5_CALL(h5tcreate_f, H5T_COMPOUND_F, INT(2*comp_size, SIZE_T), type_id)
         @:HDF5_CALL(h5tinsert_f, type_id, 're', INT(0, SIZE_T), comp_type_id)
         @:HDF5_CALL(h5tinsert_f, type_id, 'im', INT(comp_size, SIZE_T), comp_type_id)

         ! Finish

         return

      end subroutine create_complex_type_

   end subroutine open_library_

   !****

   subroutine final_(this)

      class(hgroup_t), intent(inout) :: this

      integer :: hdf_err

      ! Close the group

      @:HDF5_CALL(h5gclose_f, this%group_id)

      this%ref_count = this%ref_count - 1

      ! If necessary, close the file also

      if(this%ref_count == 0) then
         @:HDF5_CALL(h5fclose_f, this%file_id)
         deallocate(this%ref_count)
         ref_count = ref_count - 1
      endif

      ! If necessary, close the HDF5 library

      if(ref_count == 0) then
         call close_library_()
      endif

      ! Finish

      return

   end subroutine final_

   !****

   subroutine close_library_()

      integer :: hdf_err

      ! Close complex data types

      @:HDF5_CALL(h5tclose_f, c_dp_mem_type_id)

      @:HDF5_CALL(h5tclose_f, c_dp_file_type_id)

      ! Close the HDF5 library

      @:HDF5_CALL(h5close_f)

      ! Finish

      return

   end subroutine close_library_

   !****

   function exists_(this, group_name)

      class(hgroup_t), intent(inout) :: this
      character(*), intent(in)       :: group_name
      logical                        :: exists_

      integer        :: hdf_err
      integer(HID_T) :: group_id

      ! Determine whether the named group already exists

      call h5eset_auto_f(0, hdf_err)

      call h5gopen_f(this%group_id, group_name, group_id, hdf_err)

      if(hdf_err >= 0) then
         exists_ = .TRUE.
         call h5gclose_f(group_id, hdf_err)
      else
         exists_ = .FALSE.
      endif

      call h5eset_auto_f(1, hdf_err)

      ! Finish

      return

   end function exists_

   !****

   #:for O in ['attr', 'dset']
      #:for T, S in zip(NUM_TYPES, NUM_SUFFIXES)
         #:for R in range(0, 5)
   
            subroutine read_${O}$_${S}$_${R}$_(hg, item_name, data)

               type(hgroup_t), intent(inout) :: hg
               character(*), intent(in)      :: item_name
               ${T}$, target, intent(out)    :: data${ARRAY_SPEC(R)}$
               #:if R > 0
               contiguous :: data
               #:endif

               #:if R > 0
               integer(HSIZE_T) :: item_shape(${R}$)
               #:endif
               integer(HID_T)   :: mem_type_id
               integer          :: hdf_err
               integer(HID_T)   :: item_id
               type(C_PTR)      :: data_ptr

               #:if O == 'attr'

                  #:set OPEN_PROC = 'h5aopen_name_f'
                  #:set READ_PROC = 'h5aread_f'
                  #:set CLOSE_PROC = 'h5aclose_f'
                  #:set SHAPE_PROC = 'get_attr_shape'

               #:elif O == 'dset'

                  #:set OPEN_PROC = 'h5dopen_f'
                  #:set READ_PROC = 'h5dread_f'
                  #:set CLOSE_PROC = 'h5dclose_f'
                  #:set SHAPE_PROC = 'get_dset_shape'

               #:else

                  #:stop f'invalid object type ${O}$'

               #:endif

              ! Check the shape of the item agrees with that of data

               #:if R > 0

                  call ${SHAPE_PROC}$(hg, item_name, item_shape)
                  @:ASSERT(ALL(item_shape == SHAPE(data)), 'array shape mismatch')

               #:endif

               ! Read the item

               mem_type_id = mem_type_${S}$_()

               data_ptr = C_LOC(data)

               @:HDF5_CALL(${OPEN_PROC}$, hg%group_id, item_name, item_id)
               @:HDF5_CALL(${READ_PROC}$, item_id, mem_type_id, data_ptr)
               @:HDF5_CALL(${CLOSE_PROC}$, item_id)

               ! Finish

               return

            end subroutine read_${O}$_${S}$_${R}$_

         #:endfor
      #:endfor
   #:endfor

   !****

   #:for O in ['attr', 'dset']
      #:for R in range(0, 5)

         subroutine read_${O}$_a_${R}$_(hg, item_name, data)

            type(hgroup_t), intent(inout)     :: hg
            character(*), intent(in)          :: item_name
            character(*), target, intent(out) :: data${ARRAY_SPEC(R)}$
            #:if R > 0
               contiguous :: data
            #:endif

            #:if R > 0
               integer(HSIZE_T) :: item_shape(${R}$)
            #:endif
            integer          :: hdf_err
            integer(HID_T)   :: mem_type_id
            type(C_PTR)      :: data_ptr
            integer(HID_T)   :: item_id

            #:if O == 'attr'

              #:set OPEN_PROC = 'h5aopen_name_f'
              #:set READ_PROC = 'h5aread_f'
              #:set CLOSE_PROC = 'h5aclose_f'
              #:set SHAPE_PROC = 'get_attr_shape'

            #:elif O == 'dset'

              #:set OPEN_PROC = 'h5dopen_f'
              #:set READ_PROC = 'h5dread_f'
              #:set CLOSE_PROC = 'h5dclose_f'
              #:set SHAPE_PROC = 'get_dset_shape'

            #:else

              #:stop f'invalid object type {O}'

            #:endif

            ! Check the shape of the item agrees with that of data

            #:if R > 0

               call ${SHAPE_PROC}$(hg, item_name, item_shape)
               @:ASSERT(ALL(item_shape == SHAPE(data)), 'array shape mismatch')

            #:endif

            ! Read the character item

            @:HDF5_CALL(h5tcopy_f, H5T_NATIVE_CHARACTER, mem_type_id)
            @:HDF5_CALL(h5tset_size_f, mem_type_id, LEN(data, SIZE_T))

            data_ptr = C_LOC(data)

            @:HDF5_CALL(${OPEN_PROC}$, hg%group_id, item_name, item_id)
            @:HDF5_CALL(${READ_PROC}$, item_id, mem_type_id, data_ptr)
            @:HDF5_CALL(${CLOSE_PROC}$, item_id)

            @:HDF5_CALL(h5tclose_f, mem_type_id)

            ! Finish

            return

         end subroutine read_${O}$_a_${R}$_

      #:endfor
   #:endfor

   !****

   #:for O in ['attr', 'dset']
      #:for R in range(0, 5)

         subroutine read_${O}$_l_${R}$_(hg, item_name, data)

            type(hgroup_t), intent(inout) :: hg
            character(*), intent(in)      :: item_name
            logical, intent(out)          :: data${ARRAY_SPEC(R)}$

            integer, allocatable :: data_i${ARRAY_SPEC(R)}$

            ! Read the logical item

            call read_${O}$_alloc(hg, item_name, data_i)

            data = data_i /= 0

            ! Finish

            return

         end subroutine read_${O}$_l_${R}$_

      #:endfor
   #:endfor
         
   !****

   #:for O in ['attr', 'dset']
      #:for T, S in zip(MATH_TYPES+CHAR_TYPES, MATH_SUFFIXES+CHAR_SUFFIXES)
         #:for R in range(0, 5)
   
            subroutine read_${O}$_alloc_${S}$_${R}$_(hg, item_name, data)

               type(hgroup_t), intent(inout)     :: hg
               character(*), intent(in)          :: item_name
               ${T}$, intent(inout), allocatable :: data${ARRAY_SPEC(R)}$

               #:if R > 0
                  integer(HSIZE_T) :: item_shape(${R}$)
               #:endif

               #:if O == 'attr'

                  #:set SHAPE_PROC = 'get_attr_shape'

               #:elif O == 'dset'

                  #:set SHAPE_PROC = 'get_dset_shape'

               #:else

                  #:stop f'invalid object type {O}'

               #:endif

               ! If necessary, allocate the item

               if(ALLOCATED(data)) deallocate(data)

               #:if R > 0

                  call ${SHAPE_PROC}$(hg, item_name, item_shape)
                  allocate(data${ARRAY_SPEC(R, 'item_shape({0:d})')}$)

               #:else

                  allocate(data)

               #:endif

               ! Read the item

               call read_${O}$(hg, item_name, data)

               ! Finish

               return

            end subroutine read_${O}$_alloc_${S}$_${R}$_

         #:endfor
      #:endfor
   #:endfor

   !****

   #:for O in ['attr', 'dset']
      #:for T, S in zip(NUM_TYPES, NUM_SUFFIXES)
         #:for R in range(0, 5)

            subroutine write_${O}$_${S}$_${R}$_(hg, item_name, data, overwrite, comp_level)

               type(hgroup_t), intent(inout) :: hg
               character(*), intent(in)      :: item_name
               ${T}$, target, intent(in)     :: data${ARRAY_SPEC(R)}$
               #:if R > 0
                  contiguous :: data
               #:endif
               logical, intent(in), optional :: overwrite
               integer, intent(in), optional :: comp_level

               logical          :: overwrite_
               integer          :: hdf_err
               logical          :: item_exists
               integer(HSIZE_T) :: item_shape(${R}$)
               integer(HID_T)   :: dspace_id
               integer(HID_T)   :: plist_id
               integer(HID_T)   :: mem_type_id
               integer(HID_T)   :: file_type_id
               type(C_PTR)      :: data_ptr
               integer(HID_T)   :: item_id

               #:if O == 'attr'

                  #:set OPEN_PROC = 'h5aopen_f'
                  #:set CREATE_PROC = 'h5acreate_f'
                  #:set WRITE_PROC = 'h5awrite_f'
                  #:set CLOSE_PROC = 'h5aclose_f'
                  #:set SHAPE_PROC = 'get_attr_shape'
                  #:set EXISTS_PROC = 'attr_exists'

               #:elif O == 'dset'

                  #:set OPEN_PROC = 'h5dopen_f'
                  #:set CREATE_PROC = 'h5dcreate_f'
                  #:set WRITE_PROC = 'h5dwrite_f'
                  #:set CLOSE_PROC = 'h5dclose_f'
                  #:set SHAPE_PROC = 'get_dset_shape'
                  #:set EXISTS_PROC = 'dset_exists'

               #:else

                  #:stop f'invalid object type {O}'

               #:endif

               if(PRESENT(overwrite)) then
                  overwrite_ = overwrite
               else
                  overwrite_ = .FALSE.
               endif

               ! Write the item

               item_exists = ${EXISTS_PROC}$(hg, item_name)
               overwrite_ = overwrite_ .AND. item_exists

               if(overwrite_) then

                  call ${SHAPE_PROC}$(hg, item_name, item_shape)
                  @:ASSERT(ALL(item_shape == SHAPE(data)), 'array shape mismatch')

                  mem_type_id = mem_type_${S}$_()

                  data_ptr = C_LOC(data)

                  @:HDF5_CALL(${OPEN_PROC}$, hg%group_id, item_name, item_id)
                  @:HDF5_CALL(${WRITE_PROC}$, item_id, mem_type_id, data_ptr)
                  @:HDF5_CALL(${CLOSE_PROC}$, item_id)

               else

                  #:if R > 0
                     @:HDF5_CALL(h5screate_simple_f, ${R}$, INT(SHAPE(data), HSIZE_T), dspace_id)
                  #:else
                     @:HDF5_CALL(h5screate_f, H5S_SCALAR_F, dspace_id)
                  #:endif

                  #:if O == 'attr'
                     @:HDF5_CALL(h5pcreate_f, H5P_ATTRIBUTE_CREATE_F, plist_id)
                     @:ASSERT(.NOT. PRESENT(comp_level), 'attributes cannot be compressed')
                  #:else
                     @:HDF5_CALL(h5pcreate_f, H5P_DATASET_CREATE_F, plist_id)
                     if (PRESENT(comp_level)) then
                        @:HDF5_CALL(h5pset_chunk_f, plist_id, ${R}$, INT(SHAPE(data), HSIZE_T))
                        @:HDF5_CALL(h5pset_deflate_f, plist_id, comp_level)
                     endif
                  #:endif

                  mem_type_id = mem_type_${S}$_()
                  file_type_id = file_type_${S}$_()

                  data_ptr = C_LOC(data)

                  #:if O == 'attr'
                     @:HDF5_CALL(${CREATE_PROC}$, hg%group_id, item_name, file_type_id, dspace_id, item_id, acpl_id=plist_id)
                  #:else
                     @:HDF5_CALL(${CREATE_PROC}$, hg%group_id, item_name, file_type_id, dspace_id, item_id, dcpl_id=plist_id)
                  #:endif

                  @:HDF5_CALL(${WRITE_PROC}$, item_id, mem_type_id, data_ptr)
                  @:HDF5_CALL(h5pclose_f, plist_id)
                  @:HDF5_CALL(${CLOSE_PROC}$, item_id)
                  @:HDF5_CALL(h5sclose_f, dspace_id)

               endif

               ! Finish

               return

            end subroutine write_${O}$_${S}$_${R}$_

         #:endfor
      #:endfor
   #:endfor

   !****

   #:for O in ['attr', 'dset']
      #:for R in range(0, 5)

         subroutine write_${O}$_a_${R}$_(hg, item_name, data)

            type(hgroup_t), intent(inout)    :: hg
            character(*), intent(in)         :: item_name
            character(*), target, intent(in) :: data${ARRAY_SPEC(R)}$
            #:if R > 0
            contiguous :: data
            #:endif

            integer        :: hdf_err
            integer(HID_T) :: mem_type_id
            integer(HID_T) :: file_type_id
            integer(HID_T) :: dspace_id
            type(C_PTR)    :: data_ptr
            integer(HID_T) :: item_id

            #:if O == 'attr'

               #:set CREATE_PROC = 'h5acreate_f'
               #:set WRITE_PROC = 'h5awrite_f'
               #:set CLOSE_PROC = 'h5aclose_f'

            #:elif O == 'dset'

               #:set CREATE_PROC = 'h5dcreate_f'
               #:set WRITE_PROC = 'h5dwrite_f'
               #:set CLOSE_PROC = 'h5dclose_f'

            #:else

               #:stop f'invalid item type {O}'

            #:endif

            ! Write the character item

            @:HDF5_CALL(h5tcopy_f, H5T_NATIVE_CHARACTER, mem_type_id)
            @:HDF5_CALL(h5tset_size_f, mem_type_id, LEN(data, SIZE_T))

            @:HDF5_CALL(h5tcopy_f, H5T_NATIVE_CHARACTER, file_type_id)
            @:HDF5_CALL(h5tset_size_f, file_type_id, LEN(data, SIZE_T))

            #:if R > 0
               @:HDF5_CALL(h5screate_simple_f, ${R}$, INT(SHAPE(data), HSIZE_T), dspace_id)
            #:else
               @:HDF5_CALL(h5screate_f, H5S_SCALAR_F, dspace_id)
            #:endif

            data_ptr = C_LOC(data)

            @:HDF5_CALL(${CREATE_PROC}$, hg%group_id, item_name, file_type_id, dspace_id, item_id)
            @:HDF5_CALL(${WRITE_PROC}$, item_id, mem_type_id, data_ptr)
            @:HDF5_CALL(${CLOSE_PROC}$, item_id)

            @:HDF5_CALL(h5sclose_f, dspace_id)

            @:HDF5_CALL(h5tclose_f, mem_type_id)
            @:HDF5_CALL(h5tclose_f, file_type_id)

            ! Finish

            return

         end subroutine write_${O}$_a_${R}$_

      #:endfor
   #:endfor

   !****

   #:for O in ['attr', 'dset']
      #:for R in range(0, 5)

         subroutine write_${O}$_l_${R}$_(hg, item_name, data)

            type(hgroup_t), intent(inout) :: hg
            character(*), intent(in)      :: item_name
            logical, intent(in)           :: data${ARRAY_SPEC(R)}$

            ! Write the logical item

            call write_${O}$(hg, item_name, MERGE(1, 0, MASK=data))

            ! Finish

            return

         end subroutine write_${O}$_l_${R}$_

      #:endfor
   #:endfor

   !****

   subroutine get_attr_shape(hg, attr_name, shape)

      type(hgroup_t), intent(inout) :: hg
      character(*), intent(in)      :: attr_name
      integer(HSIZE_T), intent(out) :: shape(:)

      integer          :: hdf_err
      integer(HID_T)   :: attr_id
      integer(HID_T)   :: space_id
      integer          :: rank
      integer(HSIZE_T) :: max_shape(SIZE(shape))

      ! Get the shape of the attribute

      @:HDF5_CALL(h5aopen_name_f, hg%group_id, attr_name, attr_id)

      @:HDF5_CALL(h5aget_space_f, attr_id, space_id)

      @:HDF5_CALL(h5sget_simple_extent_ndims_f, space_id, rank)
      @:ASSERT(rank == SIZE(shape), 'rank mismatch')

      @:HDF5_CALL(h5sget_simple_extent_dims_f, space_id, shape, max_shape)

      @:HDF5_CALL(h5sclose_f, space_id)
      @:HDF5_CALL(h5aclose_f, attr_id)

      ! Finish

      return

   end subroutine get_attr_shape

   !****

   subroutine get_dset_shape(hg, dset_name, shape)

      type(hgroup_t), intent(inout) :: hg
      character(*), intent(in)      :: dset_name
      integer(HSIZE_T), intent(out) :: shape(:)

      integer          :: hdf_err
      integer(HID_T)   :: dset_id
      integer(HID_T)   :: space_id
      integer          :: rank
      integer(HSIZE_T) :: max_shape(SIZE(shape))

      ! Get the shape of the dataset

      @:HDF5_CALL(h5dopen_f, hg%group_id, dset_name, dset_id)

      @:HDF5_CALL(h5dget_space_f, dset_id, space_id)

      @:HDF5_CALL(h5sget_simple_extent_ndims_f, space_id, rank)
      @:ASSERT(rank == SIZE(shape), 'rank mismatch')

      @:HDF5_CALL(h5sget_simple_extent_dims_f, space_id, shape, max_shape)

      @:HDF5_CALL(h5sclose_f, space_id)
      @:HDF5_CALL(h5dclose_f, dset_id)

      ! Finish

      return

   end subroutine get_dset_shape

   !****

   function attr_exists_(hg, attr_name) result(attr_exists)

      type(hgroup_t), intent(inout) :: hg
      character(*), intent(in)      :: attr_name
      logical                       :: attr_exists

      integer :: hdf_err

      ! Check if the attribute exists

      @:HDF5_CALL(h5aexists_f, hg%group_id, attr_name, attr_exists)

      ! Finish

      return

   end function attr_exists_

   !****

   function dset_exists_(hg, dset_name) result(dset_exists)

      type(hgroup_t), intent(inout) :: hg
      character(*), intent(in)      :: dset_name
      logical                       :: dset_exists

      integer          :: hdf_err
      logical          :: link_exists
      type(h5o_info_t) :: obj_info

      ! Check if the dataset exists

      @:HDF5_CALL(h5lexists_f, hg%group_id, dset_name, link_exists)

      if(link_exists) then

         @:HDF5_CALL(h5oget_info_by_name_f, hg%group_id, dset_name, obj_info)

         dset_exists = obj_info%type == H5O_TYPE_DATASET_F

      else

         dset_exists = .FALSE.

      endif

      ! Finish

      return

   end function dset_exists_

   !****

   function mem_type_i_() result(mem_type_id)

      integer(HID_T) :: mem_type_id

      ! Determine the memory type for integers

      mem_type_id = h5kind_to_type(KIND(0), H5_INTEGER_KIND)

      ! Finish

      return

   end function mem_type_i_

   !****

   function mem_type_r_() result(mem_type_id)

      integer(HID_T) :: mem_type_id

      ! Determine the memory type for reals

      mem_type_id = h5kind_to_type(DP, H5_REAL_KIND)

      ! Finish

      return

   end function mem_type_r_

   !****

   function mem_type_c_() result(mem_type_id)

      integer(HID_T) :: mem_type_id

      ! Determine the memory type for complexes

      mem_type_id = c_dp_mem_type_id

      ! Finish

      return

   end function mem_type_c_

   !****

   function file_type_i_() result(file_type_id)

      integer(HID_T) :: file_type_id

      ! Determine the file type for integers

      file_type_id = H5T_STD_I32LE

      ! Finish

      return

   end function file_type_i_
   
   !****

   function file_type_r_() result(file_type_id)

      integer(HID_T) :: file_type_id

      ! Determine the file type for reals

      file_type_id = H5T_IEEE_F32LE

      ! Finish

      return

   end function file_type_r_

   !****

   function file_type_c_() result(file_type_id)

      integer(HID_T) :: file_type_id

      ! Determine the file type for complexes

      file_type_id = c_dp_file_type_id

      ! Finish

      return

   end function file_type_c_

   !****

   function elem_group_name(prefix, indices) result(group_name)

      character(*), intent(in)  :: prefix
      integer, intent(in)       :: indices(:)
      character(:), allocatable :: group_name

      integer                   :: n_indices
      character(:), allocatable :: name_format
      integer                   :: name_len
      integer                   :: i

      ! Set up an array-element group name

      n_indices = SIZE(indices)

      select case(n_indices)
      case(0)
         name_format = '(A,''()'')'
      case(1)
         name_format = '(A,''('',I0,'')'')'
      case default
         name_format = '(A,''('''//REPEAT('I0,'',''', n_indices-1)//'I0,'')'')'
      end select

      name_len = LEN_TRIM(prefix) + n_indices + 1

      do i = 1,SIZE(indices)
         if(indices(i) < 0) then
            name_len = name_len + FLOOR(LOG10(REAL(ABS(indices(i))))) + 2
         elseif(indices(i) > 0) then
            name_len = name_len + FLOOR(LOG10(REAL(indices(i)))) + 1
         else
            name_len = name_len + 1
         endif
      end do

      allocate(character(name_len) :: group_name)

      write(group_name, name_format) TRIM(prefix), indices

      ! Finish

      return

   end function elem_group_name

end module hgroup_m
